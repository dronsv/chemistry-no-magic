# Процессы в онтологии курса химии: зачем и как кодировать

## Контекст
В текущей базе реакций (`reactions.json`) реакция описана как объект с:
- молекулярным представлением (reactants/products),
- ионными уравнениями (full/net) строками,
- условиями (conditions), средой (phase.medium),
- "движущими силами" (driving_forces),
- наблюдениями, советами по скорости, безопасностью,
- иногда блоком ОВР (redox).

Это уже близко к knowledge graph: Reaction — отдельная сущность, связывающая вещества и метаданные. `reactions.json` при этом содержит процессы имплицитно: например нагрев ("—t°→"), выделение газа ("↑"), осаждение ("↓"), поглощение газа, влияние разбавления и перемешивания.

## Главная идея
Да, реакция сама по себе — процесс. Но для расчётной энергетики важно различать 3 уровня:

1) **Термодинамика реакции** (ΔH, ΔG, ΔS) — свойства перехода "реагенты → продукты" при заданных состояниях.
2) **Кинетика** (барьер/скорость) — зависит от перемешивания, поверхности, катализа, температуры.
3) **Операционные/физико-химические процессы** (нагревание, растворение, осаждение, удаление газа) — меняют условия системы, тем самым влияя на (1) и (2).

Если всё назвать "процессами" без типизации, мы потеряем семантику:
- реакция меняет химический состав,
- нагрев меняет температуру,
- фильтрация меняет состав смеси, но не химическую природу веществ,
- осаждение/удаление газа меняют активность компонентов и смещают равновесие.

Поэтому в онтологии вводим **контролируемый словарь процессов**, но делим их на классы:
- ChemicalReaction (химическое преобразование),
- PhysChemProcesses (осаждение, выделение/поглощение газа, диссоциация, комплексообразование),
- Operations (нагрев, перемешивание, разбавление, фильтрация),
- Constraints (формальное "продукт уходит", если нужно).

## Минимальная схема данных (совместимая с текущим форматом)
Оставляем Reaction как есть, но добавляем два новых блока:

### 1) `thermo` (термодинамика реакции)
Пример полей:
- reference: {T_K, p_bar}
- deltaH_kJ_per_mol
- deltaG_kJ_per_mol
- deltaS_J_per_molK
- confidence: measured | tabulated | estimated
- method: hess_from_formation | bond_energy_estimate | unknown

### 2) `processes` (процессы/операции/события)
Храним как массив объектов со ссылкой на vocabulary:
- {id: "heating", params:{...}}
- {id: "gas_evolution", params:{gas_substance_id:"CO2_g", vented:true}}
- {id: "precipitation", params:{solid_substance_id:"BaSO4_s"}}

Важно: `processes` не дублирует уравнение, а кодирует **путь/условия/эффекты**, нужные для энергетики/равновесия/скорости и для объяснений.

## Зачем это нужно (мотивация)
### 1) Энергетика (ΔH/ΔG) становится вычислимой и объяснимой
- Нейтрализация: экзотермична; можно хранить оценку ΔH и показывать энергетический профиль.
- Разложение CaCO3: эндотермично и требует подвода тепла — это не просто "условие", а операционный процесс heating.

### 2) "Почему реакция идёт до конца" — формализуется
Ваши driving_forces уже описывают это ("gas_release", "precipitation", "water_formation").
Процессы позволяют сделать это машинно-используемым:
- precipitation -> продукт уходит в твёрдую фазу
- gas_evolution + remove_gas -> продукт удаляется
- water_formation -> образование слабого электролита (H2O) в ионных реакциях

### 3) Ионные уравнения можно автогенерировать/валидировать
Если вещества в растворе связаны с диссоциацией на ионы (через `ions.json`), то:
- full ionic строится алгоритмом "раскрыть сильные электролиты",
- net ionic получается сокращением,
- проверяется баланс заряда.

Строки `ionic.full/net` остаются для UI, но добавляется структурная форма для вычислений (опционально).

### 4) Появляются "сценарии опыта" без переписывания базы реакций
Если понадобится виртуальная лаборатория:
- вводится сущность Scenario (набор шагов operations + ссылка на reaction),
- можно учитывать Q_input для нагрева, потери тепла, порядок добавления реагентов.

## Практические правила
1) Reaction всегда остаётся узлом (с уравнением).
2) Процессы кодируем через vocabulary + params (без свободного текста в ключевых местах).
3) Не пытаемся сразу сделать полную физхимию: ΔH/ΔG могут быть unknown/estimated.
4) Сначала покрываем процессы, которые уже встречаются в текущем `reactions.json`:
    - heating (разложение CaCO3)
    - precipitation (BaSO4, AgCl, Cu(OH)2 и т.п.)
    - gas_evolution (CO2, H2, SO2, NH3, H2S)
    - gas_absorption (CO2/SO2 в щёлочи)
    - stirring/dilution/excess_reagent (из rate_tips/conditions)

## Пример: как расширить существующую реакцию (без ломки)
### Разложение CaCO3
- Было: "CaCO3(s) —t°→ CaO(s) + CO2(g)↑", heat_effect:"endo".
- Станет:
    - thermo: {deltaH: ..., confidence:"tabulated/estimated"}
    - processes: [{id:"heating", params:{mode:"heat"}},{id:"gas_evolution", params:{gas_substance_id:"CO2_g", vented:true}}]

### Осаждение BaSO4
- processes: [{id:"precipitation", params:{solid_substance_id:"BaSO4_s"}}]
- (опц.) constraint remove_solid для "идёт до конца"

## Итог
Да, реакция — процесс. Но для энергетики нужны:
- отдельная термодинамика реакции,
- отдельные операционные/физико-химические процессы как типизированные элементы.
  Это даёт вычислимость, объяснимость и расширяемость без ломки текущей структуры данных.